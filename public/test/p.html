<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Camera-only Photo Capture</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --muted:#94a3b8; --accent:#22c55e; --danger:#ef4444; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
           background: linear-gradient(180deg, #0b1025, #0a0f1e); color: #e5e7eb; min-height:100dvh; display:flex; align-items:center; justify-content:center; }
    .card { width: min(900px, 92vw); background: #0b1220; border:1px solid rgba(255,255,255,.08); border-radius: 20px; padding: 20px; box-shadow: 0 20px 70px rgba(0,0,0,.45); }
    h1 { font-size: clamp(20px, 3vw, 28px); margin:0 0 6px; }
    p.sub { margin:0 0 16px; color: var(--muted); font-size: 14px; }

    /* Portrait-first stage: smaller and capped */
    .stage { position: relative; background:#020617; border:1px solid rgba(255,255,255,.08); border-radius:16px; overflow:hidden; aspect-ratio: 3/4; display:grid; place-items:center; width: clamp(260px, 75vw, 480px); margin-inline:auto; max-height: 75vh; }
    video, canvas, img { width:100%; height:100%; object-fit: cover; display:block; }
    video { transform-origin: center center; }
    canvas, img { display:none; }

    .toolbar { display:flex; gap:10px; flex-wrap:wrap; margin-top:14px; align-items:center; }
    button { appearance: none; border:none; padding: 12px 16px; border-radius: 12px; font-weight:600; cursor:pointer; transition: transform .05s ease, box-shadow .2s ease, background .2s ease; }
    button:active { transform: translateY(1px); }
    .primary { background: var(--accent); color:#06120a; box-shadow: 0 10px 24px rgba(34,197,94,.25); }
    .secondary { background:#0b1220; border:1px solid rgba(255,255,255,.1); color:#e5e7eb; }
    .danger { background: var(--danger); color:white; }
    .ghost { background: transparent; border:1px dashed rgba(255,255,255,.15); color:#cbd5e1; }
    button[disabled] { opacity:.55; cursor:not-allowed; }

    .row { display:flex; gap:10px; }
    .row > * { flex:1 1 0; }

    .status { margin-top:10px; min-height:22px; color: var(--muted); font-size: 14px; }
    .hint { margin-top:8px; font-size:12px; color:#94a3b8; opacity:.9; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; background:#0b1220; border:1px solid rgba(255,255,255,.08); border-radius:999px; font-size:12px; }
    .dot { width:8px; height:8px; border-radius:50%; background:#10b981; }

    .topbar { display:flex; align-items:center; justify-content:space-between; margin-bottom:14px; }
    .topbar .controls { display:flex; gap:8px; }
    a { color:#93c5fd; text-decoration:none; }
  </style>
</head>
<body>
  <main class="card">
    <div class="topbar">
      <div>
        <h1>Take a photo</h1>
        <p class="sub">Camera-only. No uploads from gallery.</p>
      </div>
      <span class="pill"><span class="dot" aria-hidden="true"></span><span id="perm">Waiting for cameraâ€¦</span></span>
    </div>

    <section class="stage" aria-label="camera preview or captured photo">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
      <img id="photo" alt="Captured photo" />
    </section>

    <div class="toolbar">
      <div class="row">
        <button id="capture" class="primary">ðŸ“¸ Take photo</button>
        <button id="retake" class="secondary" hidden>â†©ï¸ Retake</button>
      </div>
      <div class="row">
        <button id="send" class="secondary" disabled>â¬†ï¸ Send</button>
        <button id="stop" class="ghost">â¹ Stop camera</button>
      </div>
    </div>

    <div class="status" id="status" role="status" aria-live="polite"></div>
    <div class="hint">
      Works over <strong>HTTPS</strong> (or <code>http://localhost</code>). This page does <em>not</em> include any file inputâ€”photos come only from your camera stream.
    </div>
  </main>

  <script>
    // ====== CONFIGURE THIS: upload endpoint ======
    const UPLOAD_URL = "/upload"; // Change to your server endpoint

    // ====== DOM ======
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const img = document.getElementById('photo');
    const captureBtn = document.getElementById('capture');
    const retakeBtn = document.getElementById('retake');
    const sendBtn = document.getElementById('send');
    const stopBtn = document.getElementById('stop');
    const statusEl = document.getElementById('status');
    const permEl = document.getElementById('perm');

    // Output config
    const TARGET_AR = 3/4;      // portrait 3:4
    const MAX_LONG_EDGE = 1080; // max px on the longer side

    let stream = null;
    let lastBlob = null;

    // Prefer the back camera on mobile; hint to browsers we want portrait framing
    const constraints = {
      video: {
        facingMode: { ideal: 'environment' },
        width: { ideal: 1920 },
        height: { ideal: 1440 },
        aspectRatio: { ideal: 0.75 }
      },
      audio: false
    };

    async function startCamera() {
      statusEl.textContent = '';
      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await video.play();
        applyPreviewRotation(); // ensure preview matches capture orientation
        permEl.textContent = 'Camera ready';
        captureBtn.disabled = false;
      } catch (err) {
        console.error(err);
        const msg = err.name === 'NotAllowedError' ?
          'Camera permission denied. Please allow access in your browser pengaturan.' :
          (err.name === 'NotFoundError' ? 'No camera device found.' : `Could not start camera: ${err.message}`);
        statusEl.textContent = msg;
        permEl.textContent = 'Blocked';
        captureBtn.disabled = true;
      }
    }

    function stopCamera() {
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      video.srcObject = null; permEl.textContent = 'Camera stopped';
    }

    function showVideo() { video.style.display = 'block'; canvas.style.display = 'none'; img.style.display = 'none'; }
    function showPhoto() { video.style.display = 'none'; canvas.style.display = 'none'; img.style.display = 'block'; }

    // --- Orientation + preview/capture consistency ---
    function computeRotation() {
      const vw = video.videoWidth || 0, vh = video.videoHeight || 0;
      if (!vw || !vh) return 0;

      const isPortraitUI = window.matchMedia && window.matchMedia('(orientation: portrait)').matches;
      let angle = 0;
      if (screen && screen.orientation && typeof screen.orientation.angle === 'number') {
        angle = screen.orientation.angle;
      }

      if (isPortraitUI) {
        // Prefer portrait output; rotate only if incoming pixels are landscape
        if (vw > vh) return (angle === 180 ? -90 : 90);
        return 0;
      } else {
        // UI is landscape; rotate only if incoming pixels are portrait
        if (vh > vw) return (angle === 270 ? -90 : 90);
        return 0;
      }
    }

    function applyPreviewRotation() {
      const deg = computeRotation();
      video.dataset.rotate = String(deg);
      video.style.transform = `rotate(${deg}deg)`;
    }

    function drawFrameToCanvas() {
      const vw = video.videoWidth || 1080;
      const vh = video.videoHeight || 1440;
      const deg = parseInt(video.dataset.rotate || '0', 10);

      // 1) Draw to working canvas, applying the same rotation used for preview
      const work = document.createElement('canvas');
      const wctx = work.getContext('2d');

      if (deg === 90 || deg === -90) { work.width = vh; work.height = vw; }
      else { work.width = vw; work.height = vh; }

      wctx.save();
      wctx.translate(work.width / 2, work.height / 2);
      wctx.rotate(deg * Math.PI / 180);
      wctx.drawImage(video, -vw / 2, -vh / 2, vw, vh);
      wctx.restore();

      // 2) Center-crop to portrait 3:4 to match stage
      let sw = work.width, sh = work.height;
      const srcAR = sw / sh; let sx = 0, sy = 0, sWidth = sw, sHeight = sh;
      if (srcAR > TARGET_AR) { sWidth = Math.round(sh * TARGET_AR); sx = Math.round((sw - sWidth) / 2); }
      else if (srcAR < TARGET_AR) { sHeight = Math.round(sw / TARGET_AR); sy = Math.round((sh - sHeight) / 2); }

      // 3) Downscale
      const longEdge = Math.max(sWidth, sHeight);
      const scale = Math.min(MAX_LONG_EDGE / longEdge, 1);
      const outW = Math.round(sWidth * scale);
      const outH = Math.round(sHeight * scale);

      canvas.width = outW; canvas.height = outH;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingQuality = 'high';
      ctx.clearRect(0, 0, outW, outH);
      ctx.drawImage(work, sx, sy, sWidth, sHeight, 0, 0, outW, outH);
    }

    async function capturePhoto() {
      if (!stream) { statusEl.textContent = 'Camera is not active.'; return; }
      drawFrameToCanvas();
      await new Promise(resolve => canvas.toBlob(blob => { lastBlob = blob; img.src = URL.createObjectURL(blob); resolve(); }, 'image/jpeg', 0.85));
      showPhoto(); sendBtn.disabled = !lastBlob; retakeBtn.hidden = false; captureBtn.hidden = true; statusEl.textContent = 'Photo captured. Ready to send.';
    }

    async function sendPhoto() {
      if (!lastBlob) return; sendBtn.disabled = true; statusEl.textContent = 'Uploadingâ€¦';
      try {
        const form = new FormData(); form.append('photo', lastBlob, `photo-${Date.now()}.jpg`);
        const res = await fetch(UPLOAD_URL, { method: 'POST', body: form });
        if (!res.ok) throw new Error(`Upload failed (${res.status})`);
        const text = await res.text(); statusEl.textContent = 'Uploaded successfully.' + (text ? ` Server said: ${text}` : '');
      } catch (e) { console.error(e); statusEl.textContent = `Upload error: ${e.message}`; sendBtn.disabled = false; }
    }

    function retake() { lastBlob = null; sendBtn.disabled = true; retakeBtn.hidden = true; captureBtn.hidden = false; showVideo(); statusEl.textContent = 'Live preview.'; }

    // Wire up UI
    captureBtn.addEventListener('click', capturePhoto);
    retakeBtn.addEventListener('click', retake);
    sendBtn.addEventListener('click', sendPhoto);
    stopBtn.addEventListener('click', () => { stopCamera(); statusEl.textContent = 'Camera stopped.'; });

    // Keep preview rotation correct once metadata is known or if layout changes
    video.addEventListener('loadedmetadata', applyPreviewRotation);
    window.addEventListener('resize', applyPreviewRotation);

    // Start automatically where allowed; some browsers require a user gesture.
    if ('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) { startCamera(); }
    else { permEl.textContent = 'Unsupported browser'; statusEl.textContent = 'Your browser does not support camera capture (getUserMedia).'; captureBtn.disabled = true; }

    // Cleanup on page unload
    window.addEventListener('beforeunload', stopCamera);
  </script>
</body>
</html>

